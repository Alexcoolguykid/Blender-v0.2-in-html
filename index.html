<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Modeling HTML</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
            height: 100%;
        }

        #menu-container {
            position: absolute;
            top: 0;
            right: 0;
            width: 300px;
            height: 100%;
            background-color: rgba(240, 240, 240, 0.8); /* Transparent background */
            display: none;
            flex-direction: column;
            padding: 10px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2);
            overflow-y: auto; /* Make menu scrollable */
        }

        #menu-container h3 {
            margin-top: 0;
        }

        .menu button, .menu input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }

        #toggle-menu-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            cursor: pointer;
            z-index: 10;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #scene-list {
            list-style: none;
            padding: 0;
        }

        #scene-list li {
            cursor: pointer;
            padding: 5px;
            background-color: #ddd;
            margin-bottom: 5px;
            text-align: center;
        }

        #scene-list li:hover {
            background-color: #bbb;
        }
    </style>
</head>
<body>

<!-- Button to toggle the menu -->
<button id="toggle-menu-btn" onclick="toggleMenu()">Menu</button>

<!-- Transparent menu container -->
<div id="menu-container" onclick="event.stopPropagation();">
    <div class="menu" id="object-menu">
        <h3>Objects</h3>
        <button onclick="addCube()">Add Cube</button>
        <button onclick="addSphere()">Add Sphere</button>
        <button onclick="addTorus()">Add Torus</button>
        <button onclick="addCone()">Add Cone</button> <!-- Add Cone button -->
        <button onclick="addCylinder()">Add Cylinder</button> <!-- Add Cylinder button -->
        <button onclick="addTorusKnot()">Add Torus Knot</button> <!-- Add Torus Knot button -->
    </div>

    <div class="menu" id="edit-menu">
        <h3>Editing Tools</h3>
        <button onclick="toggleMoveMode()">Move (M)</button>
        <button onclick="toggleScaleMode()">Scale (S)</button>
        <button onclick="toggleRotateMode()">Rotate (R)</button>
        <button onclick="duplicateSelectedObject()">Duplicate (D)</button> <!-- Duplicate button -->
        <button onclick="toggleRealisticShaders()">Toggle Realistic Shaders</button>
        <label for="colorPicker">Color:</label>
        <input type="color" id="colorPicker" onchange="changeColor(this.value)">
    </div>

    <div class="menu" id="material-editor">
        <h3>Material Editor</h3>
        <label for="transparency">Transparency:</label>
        <input type="range" id="transparency" min="0" max="1" step="0.01" value="1" oninput="changeTransparency(this.value)">
        <label for="shininess">Shininess:</label>
        <input type="range" id="shininess" min="0" max="100" step="1" value="10" oninput="changeShininess(this.value)">
    </div>

    <div class="menu">
        <h3>Light Controls</h3>
        <label for="lightIntensity">Light Intensity</label>
        <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="1" oninput="changeLightIntensity(this.value)">
        <label for="lightDirection">Light Direction</label>
        <input type="range" id="lightDirection" min="0" max="360" step="1" value="0" oninput="changeLightDirection(this.value)">
    </div>

    <div class="menu">
        <h3>Scene</h3>
        <ul id="scene-list"></ul>
    </div>

    <div class="menu">
        <h3>Background</h3>
        <label for="voidColor">Change Void Color:</label>
        <input type="color" id="voidColor" value="#000000" onchange="changeVoidColor(this.value)">
    </div>
</div>

<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000); // Default background color (void color)
    renderer.shadowMap.enabled = true; // Enable shadow maps
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.10;

    const transformControls = new THREE.TransformControls(camera, renderer.domElement);
    transformControls.addEventListener('dragging-changed', event => {
        controls.enabled = !event.value;
    });
    scene.add(transformControls);

    let selectedObject = null;

    // Directional Light with shadow properties
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 0);
    light.castShadow = true; // Enable shadow casting for the light
    light.shadow.mapSize.width = 1024; // Default shadow map size
    light.shadow.mapSize.height = 1024;
    light.shadow.camera.near = 0.5; // Default shadow camera near
    light.shadow.camera.far = 50; // Default shadow camera far
    scene.add(light);

    function addObjectToScene(object) {
        scene.add(object);
        updateSceneList();
    }

    function addCube() {
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.5, roughness: 0.5 });
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true; // Enable shadow casting for the cube
        cube.receiveShadow = true; // Enable shadow receiving for the cube
        setupObjectInteraction(cube);
        addObjectToScene(cube);
    }

    function addSphere() {
        const geometry = new THREE.SphereGeometry(0.75, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.5 });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.castShadow = true; // Enable shadow casting for the sphere
        sphere.receiveShadow = true; // Enable shadow receiving for the sphere
        setupObjectInteraction(sphere);
        addObjectToScene(sphere);
    }

    function addTorus() {
        const geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
        const material = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.5, roughness: 0.5 });
        const torus = new THREE.Mesh(geometry, material);
        torus.castShadow = true; // Enable shadow casting for the torus
        torus.receiveShadow = true; // Enable shadow receiving for the torus
        setupObjectInteraction(torus);
        addObjectToScene(torus);
    }

    function addCone() {
        const geometry = new THREE.ConeGeometry(0.5, 1, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.5, roughness: 0.5 });
        const cone = new THREE.Mesh(geometry, material);
        cone.castShadow = true; // Enable shadow casting for the cone
        cone.receiveShadow = true; // Enable shadow receiving for the cone
        setupObjectInteraction(cone);
        addObjectToScene(cone);
    }

    function addCylinder() {
        const geometry = new THREE.CylinderGeometry(0.75, 0.75, 1.5, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0xff00ff, metalness: 0.5, roughness: 0.5 });
        const cylinder = new THREE.Mesh(geometry, material);
        cylinder.castShadow = true; // Enable shadow casting for the cylinder
        cylinder.receiveShadow = true; // Enable shadow receiving for the cylinder
        setupObjectInteraction(cylinder);
        addObjectToScene(cylinder);
    }

    function addTorusKnot() {
        const geometry = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, metalness: 0.5, roughness: 0.5 });
        const torusKnot = new THREE.Mesh(geometry, material);
        torusKnot.castShadow = true; // Enable shadow casting for the torus knot
        torusKnot.receiveShadow = true; // Enable shadow receiving for the torus knot
        setupObjectInteraction(torusKnot);
        addObjectToScene(torusKnot);
    }

    function setupObjectInteraction(object) {
        object.name = object.type; // Set object name for the scene list
        object.userData.isSelected = false; // Track selection status
    }

    function selectObject(object) {
        if (selectedObject) {
            deselectObject();
        }
        selectedObject = object;
        object.userData.isSelected = true; // Mark as selected
        transformControls.attach(object);
        updateSceneList();
        object.material.emissive.set(0xffff00); // Yellow outline effect
    }

    function deselectObject() {
        if (selectedObject) {
            selectedObject.userData.isSelected = false; // Mark as deselected
            transformControls.detach();
            selectedObject.material.emissive.set(0x000000); // Remove outline effect
            selectedObject = null;
            updateSceneList();
        }
    }

    function updateSceneList() {
        const sceneList = document.getElementById('scene-list');
        sceneList.innerHTML = '';
        scene.children.forEach(child => {
            if (child instanceof THREE.Mesh) {
                const listItem = document.createElement('li');
                listItem.textContent = child.name || 'Unnamed';
                listItem.onclick = () => selectObject(child);
                sceneList.appendChild(listItem);
            }
        });
    }

    function toggleMoveMode() {
        transformControls.setMode('translate');
    }

    function toggleScaleMode() {
        transformControls.setMode('scale');
    }

    function toggleRotateMode() {
        transformControls.setMode('rotate');
    }

    function duplicateSelectedObject() {
        if (selectedObject) {
            // Clone the selected object
            const newObject = selectedObject.clone();
            newObject.position.x += 1; // Move the duplicate to the right

            // Ensure that the new object is a separate mesh
            newObject.userData.isSelected = false; // Mark as not selected
            newObject.name = selectedObject.name; // Maintain the name for clarity

            // Add the new object to the scene
            scene.add(newObject);
            
            updateSceneList(); // Update the scene list to include the new object
            deselectObject(); // Deselect the original object
        }
    }

    function toggleRealisticShaders() {
        const material = selectedObject.material;
        if (material) {
            material.metalness = material.metalness === 0 ? 1 : 0;
            material.roughness = material.roughness === 0 ? 0 : 0.5;
            material.needsUpdate = true;
        }
    }

    function changeColor(color) {
        if (selectedObject) {
            selectedObject.material.color.set(color);
        }
    }

    function changeTransparency(value) {
        if (selectedObject) {
            selectedObject.material.transparent = true;
            selectedObject.material.opacity = value;
            selectedObject.material.needsUpdate = true;
        }
    }

    function changeShininess(value) {
        if (selectedObject) {
            selectedObject.material.shininess = value;
            selectedObject.material.needsUpdate = true;
        }
    }

    function changeLightIntensity(value) {
        light.intensity = value;
    }

    function changeLightDirection(value) {
        light.position.x = Math.sin(THREE.MathUtils.degToRad(value));
        light.position.z = Math.cos(THREE.MathUtils.degToRad(value));
    }

    function changeVoidColor(color) {
        renderer.setClearColor(color); // Change the background (void) color
    }

    function deleteSelectedObject() {
        if (selectedObject) {
            scene.remove(selectedObject);
            selectedObject = null;
            transformControls.detach();
            updateSceneList(); // Update the scene list to reflect the deletion
        }
    }

    // Listen for the 'keydown' event to delete the selected object with Backspace
    window.addEventListener('keydown', (event) => {
        if (event.key === 'Backspace' && selectedObject) {
            deleteSelectedObject();
        }
        if (event.key === 'm') { // Move tool shortcut
            toggleMoveMode();
        }
        if (event.key === 's') { // Scale tool shortcut
            toggleScaleMode();
        }
        if (event.key === 'r') { // Rotate tool shortcut
            toggleRotateMode();
        }
        if (event.key === 'd') { // Duplicate tool shortcut
            duplicateSelectedObject();
        }
    });

    // Add raycaster for click selection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
            const clickedObject = intersects[0].object;
            selectObject(clickedObject);
        } else {
            deselectObject(); // Deselect if clicking outside of an object
        }
    }

    window.addEventListener('click', onMouseClick);

    function toggleMenu() {
        const menu = document.getElementById('menu-container');
        menu.style.display = menu.style.display === 'none' ? 'flex' : 'none';
    }

    // Prevent deselecting when clicking inside the menu
    document.getElementById('menu-container').addEventListener('click', (event) => {
        event.stopPropagation(); // Stop the click event from bubbling up
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });
</script>
</body>
</html>
